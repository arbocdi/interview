
# Неблокирующие ретраи в Kafka + Spring (Spring for Apache Kafka) — конспект

Идея: **не держать “зависшим” consumer-поток**, когда обработка упала и надо подождать before retry.
Вместо `sleep` в обработчике — **перекладываем сообщение в отдельный retry-топик**.

---

## 1) Почему блокирующие ретраи — плохо

* consumer-поток простаивает во время backoff
* падает throughput
* растут consumer lag'и
* увеличивается риск rebalance

---

## 2) Retry Topics — базовый принцип

Spring Kafka использует паттерн **Retry Topics**:

* `main-topic` — читаем сразу
* `retry-topic-1` — первая задержка
* `retry-topic-2` — следующая задержка
* ...
* `DLT` — сообщения, которые больше не ретраим

Ожидание реализуется **не Kafka**, а Spring'ом.

---

## 3) ASCII-схема

```
Producer
   |
   v
+-------------+
| main-topic  |----------------------------------
+------+------+                                 |
       |                                        |
       | exception                              |
       v                                        |
+--------------------+                          |
| retry-topic-1 10s  |                          |
+---------+----------+                          |
          | exception                           |
          v                                     |
+--------------------+                          | noRetryFor(BusinessException) 
| retry-topic-2 30s  |                          |
+---------+----------+                          |
          | exception                           |
          v                                     |
+--------------------+                          |    
| retry-topic-3 2m   |                          |
+---------+----------+                          |
          | exception                           |
          v                                     |
+--------------------+                          |
| DLT                |<--------------------------
+--------------------+
          |
          v
     @DltHandler
```

---

## 4) Что реально «не блокируется»

* потоки consumer'ов main-topic
* ретраи обрабатываются асинхронно
* retry и main могут обрабатываться параллельно

---

## 5) Важные последствия

### Порядок сообщений
* порядок между main и retry **не гарантирован**
* обязательно проектировать обработчики идемпотентными

### Ack и коммиты
* сообщение из main-topic **коммитится**
* retry = **новая публикация**

---

## 6) Аннотация @RetryableTopic

```java
@RetryableTopic(
    attempts = "5",
    backoff = @Backoff(
        delay = 10_000,
        multiplier = 2.0,
        maxDelay = 120_000
    )
)
@KafkaListener(topics = "account-events")
public void on(String payload) {
    ...
}
```

Spring сам:
* создаёт retry/DLT топики
* маршрутизирует сообщения
* управляет задержками

---

## 7) @DltHandler

```java
@DltHandler
public void onDlt(String payload) {
    // логирование, алерты, ручная обработка
}
```

Используется для:
* бизнес-ошибок
* исчерпанных попыток
* отладки проблемных сообщений

---

## 8) Классификация ошибок

**Retryable**
* сетевые ошибки
* timeout
* временные 5xx

**Non-retryable**
* бизнес-валидация
* невалидные данные
* нарушение инвариантов

---

## 9) Продакшен-чеклист

* идемпотентная обработка
* inbox / outbox
* метрики по retry и DLT
* алерты по росту DLT

---

## 10) Кратко

> Retry Topics — это способ вынести ожидание из consumer-потока в отдельные Kafka-топики,
> сохранив throughput и управляемость.

## Потоковая модель Spring Kafka + Retry Topics (коротко)

Пусть:
- `concurrency = n` в `ConcurrentKafkaListenerContainerFactory`
- `attempts = k` в `@RetryableTopic`

### Что означает `concurrency = n`

- Spring создаёт **n consumer-потоков** на **каждый топик**
- Поток ≠ партиция  
  Реальный параллелизм = `min(concurrency, partitions)`

---

### Как retry topics влияют на потоки

При `attempts = k` появляется:

- 1 × основной топик
- (k − 1) × retry-топиков
- 1 × DLT

Каждый из них:
- имеет **свой listener container**
- использует тот же `concurrency = n` (если не указано иное)

---

### Сколько потоков всего

Общее количество consumer-потоков:
```
(main + retries + DLT) × concurrency= (k + 1) × n
```

---

### Важные нюансы

- Потоки создаются, но **могут простаивать**, если в retry-топике нет готовых сообщений
- Потоки **изолированы по топикам** — долгие ретраи не тормозят основной поток
- Ограничение всегда задаётся **числом партиций**

---

### Интуитивно

> Retry Topics увеличивают не latency,  
> а **ширину конвейера обработки**.

Ты платишь потоками → получаешь неблокирующие ретраи и изоляцию нагрузки.
