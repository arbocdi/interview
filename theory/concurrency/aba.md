# ABA‑проблема в Java (краткий конспект)

## Что такое ABA

**ABA** — ситуация при использовании CAS, когда:

```
A → B → A
```

Значение (или ссылка) вернулось к прежнему (`A`), и `CAS` **не замечает**, что между чтением и обновлением состояние уже менялось.

CAS сравнивает **только текущее значение**, а не историю изменений.

---

## Почему ABA — не всегда проблема

### ❌ Не проблема для примитивных атомиков

```java
AtomicInteger x;
// 1 → 2 → 1
```

* значение полностью описывает состояние
* нет скрытых связей
* если снова `1` — это корректное состояние

➡️ ABA формально есть, но **семантически безопасно**.

---

## Где ABA становится реальной проблемой

### ✅ Pointer‑based структуры

```java
AtomicReference<Node> head;

class Node {
    int value;
    Node next;
}

Node pop() {
    Node oldHead;
    Node newHead;
    do {
        oldHead = head.get();
        if (oldHead == null) return null;
        newHead = oldHead.next;
    } while (!head.compareAndSet(oldHead, newHead));
    return oldHead;
}


```

Когда значение CAS — **ссылка на узел**, за ней скрыта структура (`next`, связи, инварианты).

CAS проверяет только:

```
head == oldHead
```

но **не знает**, что происходило с графом объектов между чтением и CAS.

---

## Классический пример: lock‑free стек (Treiber stack)

Начальное состояние:

```
head → A → B → C
```

### Поток T1 (pop)

* читает `oldHead = A`
* запоминает `newHead = B`
* приостанавливается

### Поток T2

1. pop → снимает A
2. pop → снимает B
3. push(A) → кладёт **тот же объект A** обратно

Состояние:

```
head → A → C
```

### Поток T1 продолжает

```java
CAS(head, A → B) // успешно!
```

➡️ Стек повреждён: `B` логически удалён, но в стеке он все равно есть.

---

## Почему GC не спасает

* ABA — **логическая**, а не memory‑free проблема
* объект `A` может:

    * остаться жив
    * быть повторно использован
    * иметь ту же ссылку

GC не предотвращает A → B → A.

---

## Связь с TOCTOU

ABA — частный случай **TOCTOU**:

> *прочитал → мир изменился → проверка всё ещё «успешна»*

В lock‑free структурах это критично.

---

## Как решают ABA

### 1️⃣ AtomicStampedReference (versioning)

```java
AtomicStampedReference<Node> head;
```

CAS сравнивает:

```
(Node, stamp)
```

Теперь:

```
A(1) → B → A(2)
```

CAS по `(A,1)` ❌ не проходит.

➡️ Аналог `@Version` в БД.

---

### 2️⃣ AtomicMarkableReference

* бинарный флаг изменения
* часто для lazy delete

---

### 3️⃣ Hazard Pointers / Epoch‑based reclamation

* откладывают повторное использование узлов
* редко применяются в Java

---

## Почему ABA не проблема для ReentrantLock / AQS

* CAS используется только как **fast‑path**
* структура защищена блокировкой
* нет lock‑free модификации связанных структур

➡️ ABA **концептуально неприменима**.

---

## Ключевая мысль

> **ABA — это проблема не CAS, а модели состояния поверх CAS.**

Опасно, когда:

* CAS‑значение = указатель / ссылка
* за значением скрыта изменяемая структура

Безопасно, когда:

* значение самодостаточно (число, флаг, счётчик).

---

## Короткая таблица

| Механизм                | ABA |
| ----------------------- | --- |
| AtomicInteger / Long    | ❌   |
| AtomicBoolean           | ❌   |
| AtomicReference<Node>   | ⚠️  |
| Lock‑free stack / queue | ⚠️  |
| ReentrantLock / AQS     | ❌   |
